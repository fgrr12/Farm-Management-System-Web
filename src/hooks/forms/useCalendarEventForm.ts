import { zodResolver } from '@hookform/resolvers/zod'
import dayjs from 'dayjs'
import { useCallback } from 'react'
import { useForm } from 'react-hook-form'
import { useTranslation } from 'react-i18next'

import { type CalendarEventFormData, calendarEventSchema } from '@/schemas'

const DEFAULT_VALUES: Partial<CalendarEventFormData> = {
	title: '',
	description: '',
	type: 'task',
	priority: 'medium',
	date: '',
	time: '',
	relatedType: undefined,
	relatedId: '',
	status: 'pending',
	isAutoGenerated: false,
}

export const useCalendarEventForm = (
	initialData?: Partial<CalendarEvent>,
	selectedDate?: dayjs.Dayjs | null
) => {
	const { t } = useTranslation(['calendar'])

	const getDefaultValues = useCallback((): Partial<CalendarEventFormData> => {
		if (initialData) {
			const eventDate = dayjs(initialData.date)
			return {
				uuid: initialData.uuid || '',
				farmUuid: initialData.farmUuid || '',
				title: initialData.title || '',
				description: initialData.description || '',
				type: initialData.type || 'task',
				priority: initialData.priority || 'medium',
				date: eventDate.format('YYYY-MM-DD'),
				time: initialData.time || '',
				relatedType: initialData.relatedType,
				relatedId: initialData.relatedId || '',
				status: initialData.status || 'pending',
				isAutoGenerated: initialData.isAutoGenerated || false,
				createdAt: initialData.createdAt,
				updatedAt: initialData.updatedAt,
				createdBy: initialData.createdBy,
			}
		}

		if (selectedDate) {
			return {
				...DEFAULT_VALUES,
				date: selectedDate.format('YYYY-MM-DD'),
				time: dayjs().add(1, 'hour').startOf('hour').format('HH:mm'),
			}
		}

		return DEFAULT_VALUES
	}, [initialData, selectedDate])

	const form = useForm<CalendarEventFormData>({
		resolver: zodResolver(calendarEventSchema),
		defaultValues: getDefaultValues(),
		mode: 'onChange',
		reValidateMode: 'onChange',
	})

	const transformToApiFormat = useCallback(
		(
			data: CalendarEventFormData
		):
			| CalendarEvent
			| Omit<CalendarEvent, 'uuid' | 'createdAt' | 'farmUuid' | 'updatedAt' | 'createdBy'> => {
			// Combinar fecha y hora para crear el dateTime
			const dateTime = data.time
				? dayjs(`${data.date} ${data.time}`)
				: dayjs(data.date).startOf('day')

			const baseData: any = {
				title: data.title.trim(),
				description: data.description?.trim() || '',
				type: data.type,
				priority: data.priority,
				date: dateTime.format('YYYY-MM-DD'),
				time: data.time || '',
				status: data.status,
				isAutoGenerated: data.isAutoGenerated,
			}

			// Solo incluir relatedType y relatedId si tienen valores válidos
			if (data.relatedType) {
				baseData.relatedType = data.relatedType
			}

			if (data.relatedId && data.relatedId.trim()) {
				baseData.relatedId = data.relatedId.trim()
			}

			// Si es un evento existente (tiene uuid), incluir todos los campos
			if (data.uuid) {
				return {
					...baseData,
					uuid: data.uuid,
					farmUuid: data.farmUuid || '',
					createdBy: data.createdBy || '',
					createdAt: data.createdAt || '',
					updatedAt: data.updatedAt || '',
				} as CalendarEvent
			}

			// Si es un evento nuevo, omitir los campos que se generan automáticamente
			return baseData
		},
		[]
	)

	const getErrorMessage = useCallback(
		(message: string): string => {
			return t(message, { defaultValue: message })
		},
		[t]
	)

	return {
		...form,
		transformToApiFormat,
		getErrorMessage,
	}
}
